= Self-Contained Java EE applications with JDBC
.
2018-06-14
:jbake-type: post
:jbake-tags: gradle, wildfly, arquillian
:jbake-status: draft

In this post I would like to outline how to build a self-contained Java EE application (WAR) that uses JPA via custom JDBC-driver but with zero application-server configuration/customizing.
I will be using Java EE 8-compliant application-servers but that does not mean it is a new feature. I will work in the same way on Java EE 7.

To achieve our goal, I will leverage a feature of Java EE 7 that I always found interesting but never used due to it's limitations: `@DatasourceDefinition`.
It is a way of declaring a datasource and connection-pool within your application via annotation; instead of having to configure it outside the application via non-portable configurations-scripts for the application-server of your choice.
E.g. on JBoss you would usually configure your datasource in the `standalone.xml`; either directly or via a JBoss .cli-script.
Below you find an exmaple how you can define a datasource via annotation in your Java EE app in a portable way:

[source, java]
----
@DataSourceDefinition(
        name = "java:app/jdbc/primary",
        className = "org.postgresql.xa.PGXADataSource",
        user = "postgres",
        password = "postgres",
        serverName = "localhost",
        portNumber = 5432,
        databaseName = "postgres")
----

To me, this was never super useful because you hard-code your database-credentials. There has been a link:https://github.com/javaee/javaee-spec/blob/master/download/password-aliasing-ee7-proposal.pdf[proposal for Java EE 7] to support password-aliasing, but it never made it into the spec.
For this reason, I never used it except for very small applications and proof-of-concepts.
Until now, when a twitter-discussion lead me to realize that at least Wildfly and Payara come with vendor-specific features to do variable-replaments in the annotation-values.

But lets start from the beginning.

== Datasource-definition and JPA

Below you find a defintion and a producer for a datasource within your application:

[source, java]
----
@Singleton
@DataSourceDefinition(
        name = "java:app/jdbc/primary",
        className = "org.postgresql.xa.PGXADataSource",
        user = "postgres",
        password = "postgres",
        serverName = "postgres",
        portNumber = 5432,
        databaseName = "postgres",
        minPoolSize = 10,
        maxPoolSize = 50)
public class DatasourceProducer {
	
	@Resource(lookup="java:app/jdbc/primary")
	DataSource ds;
	
	@Produces
	public DataSource getDatasource() {
		return ds;
	}	
}
----

The `@DatasourceDefinition` annotation is sufficient here to bind the datasource for PostgreSQL under the global JNDI-name `java:app/jdbc/primary`.

The useage of `@Resource` and `@Produces` is just additional code that exposes the datasource and makes it injectable in other managed beans via `@Inject Datasource ds`.
But for JPA, this is not needed. What we need is a `persistence.xml` that uses the same JNDI-name:

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<persistence 
    version="2.1" 
    xmlns="http://xmlns.jcp.org/xml/ns/persistence" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">
    <persistence-unit name="DefaultPU" transaction-type="JTA">
        <jta-data-source>java:app/jdbc/primary</jta-data-source>
        <exclude-unlisted-classes>false</exclude-unlisted-classes>
        <properties>
            <property name="javax.persistence.schema-generation.database.action" value="drop-and-create" />
            <property name="javax.persistence.schema-generation.scripts.action" value="drop-and-create" />
            <property name="javax.persistence.schema-generation.scripts.create-target" value="schemaCreate.ddl" />
            <property name="javax.persistence.schema-generation.scripts.drop-target" value="schemaDrop.ddl" />

            <property name="eclipselink.logging.level.sql" value="FINE" />
            <property name="eclipselink.logging.level" value="FINE" />
            <property name="eclipselink.logging.level.cache" value="FINE" />

            <property name="hibernate.show_sql" value="true" />
            <property name="hibernate.format_sql" value="true" />
            <!--property name="hibernate.generate_statistics" value="true" /-->
        </properties>
    </persistence-unit>
</persistence>
----

From here on, it is plain JPA: Define some entity and inject the EntityManager via `@PersistenceContext EntityManager em;` to interact with JPA.

== Packaging of the JDBC-driver

You might have noticed that the `@DataSourceDefinition` references the JDBC-driver-class `org.postgresql.xa.PGXADataSource`.
Obviously, it has the available for the application to connect to the database.
This can be done by placing the JDBC-driver in the application-server; e.g. under Wildfly, you register the JDBC-driver as a module.
But what we want is a self-contained application where the JDBC-driver is coming with the application.
This is very simple to achieve. Just add a runtime-dependency to to the JDBC-driver. In Gradle, this is done in your `build.gradle`:

[source, groovy]
----
dependencies {
    providedCompile 'javax:javaee-api:8.0'
    runtime 'org.postgresql:postgresql:9.4.1212'
}
----

== Dynamic Configuration

What we have now is a self-contained Java EE application-archive (WAR) but the connection to the database and the credentials are hard-coded in the annotation-properties.
To make this really useful, we have to be able to overwrite this values for each deployment.
This is supported in a non-portable way by different vendors and asking the right people on Twitter lead me to the correct documentation.

=== Payara

++++
<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">For Payara here is the Documentation: <a href="https://t.co/jQMOMVLy3N">https://t.co/jQMOMVLy3N</a><br><br>I think I saw something in Wildfly docs, but Iâ€™m not sure</p>&mdash; Felipe Moraes (@fe_amoraes) <a href="https://twitter.com/fe_amoraes/status/1006611447500046336?ref_src=twsrc%5Etfw">June 12, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
++++

So, for Payara we find the documentation link:https://docs.payara.fish/documentation/payara-server/server-configuration/var-substitution/usage-of-variables.html[here].
Note that we will have to modify the annotation-values like this to read from environment variables:

[source, java]
----
@DataSourceDefinition(
        name = "java:app/jdbc/primary",
        className = "org.postgresql.xa.PGXADataSource",
        user = "${ENV=DB_USER}",
        password = "${ENV=DB_PASSWORD}",
        serverName = "${ENV=DB_SERVERNAME}",
        portNumber = 5432,
        databaseName = "${ENV=DB_DATABASENAME}",
        minPoolSize = 10,
        maxPoolSize = 50)
----


You can find this as a working Gradle-project plus Docker-Compose environment on link:https://github.com/38leinaD/jee-samples/tree/master/datasource-definition[Github].
The steps are very simple:

----
git clone https://github.com/38leinaD/jee-samples.git
cd jee-samples/datasource-definition/cars
./gradlew build
docker-compose -f docker-compose.payara.yml up
----

You will find the environment variables beeing set in the `docker-compose.payara.yml`.

=== Widlfly


++++
<blockquote class="twitter-tweet" data-conversation="none" data-lang="en"><p lang="en" dir="ltr">For WildFly, see annotation-property-replacement here: <a href="https://t.co/UCGVlNVJkj">https://t.co/UCGVlNVJkj</a></p>&mdash; OmniFaces (@OmniFaces) <a href="https://twitter.com/OmniFaces/status/1006631897034829824?ref_src=twsrc%5Etfw">June 12, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
++++

For Wildfly, you can find it under "Annotation Property Replacement" in the link:https://docs.jboss.org/author/display/WFLY/Subsystem+configuration[admin-guide].

Firstly, we have to enable the variable-replacement feature, which is not the case by default:

[source,xml]
----
<subsystem xmlns="urn:jboss:domain:ee:4.0">
    <annotation-property-replacement>true</annotation-property-replacement>
    <!-- ... -->
</subsystem>       
----

So, technically, we still hava to modify the application-server in the `standalone.xml` in this case.

But then, you can use annotation-properties in the format `${<environment-variable>:<default-value>}`:

[source, java]
----
@DataSourceDefinition(
    name = "java:app/jdbc/primary",
    className = "org.postgresql.xa.PGXADataSource",
    user = "${DB_USER:postgres}",
    password = "${DB_PASSWORD:postgres}",
    serverName = "${DB_SERVERNAME:postgres}",
    portNumber = 5432,
    databaseName = "${DB_DATABASENAME:postgres}",
    minPoolSize = 10,
    maxPoolSize = 50)
----

If you run this, you will notice the following exception:


----
Caused by: org.postgresql.util.PSQLException: FATAL: role "${DB_USER:postgres}" does not exist
	at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2455)
	at org.postgresql.core.v3.QueryExecutorImpl.readStartupMessages(QueryExecutorImpl.java:2586)
	at org.postgresql.core.v3.QueryExecutorImpl.<init>(QueryExecutorImpl.java:113)
	at org.postgresql.core.v3.ConnectionFactoryImpl.openConnectionImpl(ConnectionFactoryImpl.java:222)
	at org.postgresql.core.ConnectionFactory.openConnection(ConnectionFactory.java:52)
	at org.postgresql.jdbc.PgConnection.<init>(PgConnection.java:216)
	at org.postgresql.Driver.makeConnection(Driver.java:404)
	at org.postgresql.Driver.connect(Driver.java:272)
	at java.sql.DriverManager.getConnection(DriverManager.java:664)
	at java.sql.DriverManager.getConnection(DriverManager.java:247)
	at org.postgresql.ds.common.BaseDataSource.getConnection(BaseDataSource.java:86)
	at org.postgresql.xa.PGXADataSource.getXAConnection(PGXADataSource.java:48)
	at org.jboss.jca.adapters.jdbc.xa.XAManagedConnectionFactory.getXAManagedConnection(XAManagedConnectionFactory.java:515)
	... 133 more

----



https://issues.jboss.org/browse/WFLY-10581


[source, java]
----
@DataSourceDefinition(
    name = "java:app/jdbc/primary",
    className = "org.postgresql.xa.PGXADataSource",
    user = "postgres",
    password = "postgres",
    serverName = "${DB_SERVERNAME:postgres}",
    portNumber = 5432,
    databaseName = "${DB_DATABASENAME:postgres}",
    minPoolSize = 10,
    maxPoolSize = 50)
----

=== Liberty

Liberty does not have it yet, but there is an link:https://github.com/OpenLiberty/open-liberty/issues/3963[issue] for it:
+
++++
<blockquote class="twitter-tweet" data-conversation="none" data-cards="hidden" data-lang="en"><p lang="en" dir="ltr">No, interesting idea so I raised an issue: <a href="https://t.co/hAvZnU8opO">https://t.co/hAvZnU8opO</a></p>&mdash; Alasdair (@nottycode) <a href="https://twitter.com/nottycode/status/1006940822183596033?ref_src=twsrc%5Etfw">June 13, 2018</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
++++



== Conclusion

This is a powerful mechanism. If you wanted, you could even make the `className` dynamic and package multiple JDBC-drivers.
Hopefully standardized in the future.

JBoss
+ has defaults

Payara
+ no conif needed (annotation-property like in JBoss)
Payara: no defaults

